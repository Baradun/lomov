From a2cc87d718bcc8cc27c7c3c01c5a0f7a82be1dfc Mon Sep 17 00:00:00 2001
From: Vladimir Lomov <vladimir@theor7.ktp>
Date: Tue, 2 Mar 2021 12:34:51 +0800
Subject: [PATCH 25/30] main/main.cpp: big cleans up

  - moved some public variables to private ones;
  - removed unused variables;
  - make all matrices be complex ones;
  - get rid of 'calc_commutator', used only in one place;
  - renamed Cf4 and Cf4_3 to CF4 and CF4_3;
  - simplify calculation in CF4;
  - fixed wrong order in CF4 calculation;
  - print_more_info: it is call method, we don't need to pass a
    reference to the same instance; simplify calculations, instead of
    explicit calculation of absolute value of complex variable we use
    standard function;
  - matrix_exp_puzzer: use private variables instead of local ones and
    reassiging then to public (now private) ones; also use references
    instead of copy;
  - r0, r1 now private class variables.

Signed-off-by: Vladimir Lomov <vladimir@theor7.ktp>
---
 main/main.cpp | 138 +++++++++++++++++++++-----------------------------
 1 file changed, 57 insertions(+), 81 deletions(-)

diff --git a/main/main.cpp b/main/main.cpp
index bca0dc2..4c09b84 100644
--- a/main/main.cpp
+++ b/main/main.cpp
@@ -25,17 +25,7 @@ double f_prof(double t, double v0, double n)
 
 class Methods
 {
-
 public:
-    complex<double> p;
-    complex<double> q;
-    complex<double> lbd0;
-    complex<double> lbd1;
-    complex<double> lbd2;
-    complex<double> a;
-    complex<double> b;
-    complex<double> c;
-
     Matrix<double, 3, 3> H0;
     Matrix<double, 3, 3> W;
 
@@ -43,28 +33,24 @@ public:
         Matrix<double, 3, 3> H0,
         Matrix<double, 3, 3> W,
         Matrix<complex<double>, 3, 1> v,
-        double v0,
-        double n,
         function<double(double)> prof,
         double start,
         double end,
         double steps
-
-    ): H0(H0), W(W), v(v), v0(v0), n(n), start(start), end(end), prof(prof)
+    ): H0(H0), W(W), v(v), start(start), end(end), prof(prof)
     {
         if (steps >= 1) this->step = (end - start) / (steps);
         else this->step = steps;
     }
 
-
     Matrix<complex<double>, 3, 1> M2()
     {
-        Matrix<double, 3, 3> A;
+        Matrix<complex<double>, 3, 3> A;
         auto Y = v;
         auto point = start; 
         while (point < end)
         {
-            
+
             A = -step * (H0 + prof(point + step / 2.0) * W);
             Y = matrix_exp_puzzer(A, Y, -1.0);
 
@@ -90,7 +76,7 @@ public:
         {
             A1 = H0 + prof(point + c1 * step) * W;
             A2 = H0 + prof(point + c2 * step) * W;
-            omega = (-step / 2.0) * (A1 + A2) + 1i * (sqrt(3.0) / 12.0 * step * step) * calc_commutator(A2, A1);
+            omega = (-step / 2.0) * (A1 + A2) + 1i * (sqrt(3.0) / 12.0 * step * step) * (A2*A1-A1*A2);
             Y = matrix_exp_puzzer(omega, Y, 1.0);
 
             #ifdef DEBUG_LINTERNALS
@@ -110,11 +96,11 @@ public:
         double c2 = 0.5;
         double c3 = 0.5 + sqrt(15.0) / 10.0;
 
-        Matrix<double, 3, 3> A1;
-        Matrix<double, 3, 3> A2;
-        Matrix<double, 3, 3> A3;
+        Matrix<complex<double>, 3, 3> A1;
+        Matrix<complex<double>, 3, 3> A2;
+        Matrix<complex<double>, 3, 3> A3;
 
-        Matrix<double, 3, 3> B1, B2, B3;
+        Matrix<complex<double>, 3, 3> B1, B2, B3;
 
         Matrix<complex<double>, 3, 3> T1, T2, T3, T4;
 
@@ -152,15 +138,16 @@ public:
         return Y;
     }
 
-    Matrix<complex<double>, 3, 1> Cf4(){
-        
+    Matrix<complex<double>, 3, 1> CF4()
+    {
         double c1 = 0.5 - sqrt(3.0)/6.0;
         double c2 = 0.5 + sqrt(3.0)/6.0;
         
         double a1 = 0.25 - sqrt(3.0)/6.0;
         double a2 = 0.25 + sqrt(3.0)/6.0;
         
-        Matrix<double, 3, 3> A1, A2;
+        Matrix<complex<double>, 3, 3> A1, A2;
+        Matrix<complex<double>, 3, 3> omega;
         auto Y = v;
         auto point = start;
         while (point < end)
@@ -168,11 +155,11 @@ public:
             A1 = H0 + prof(point + c1 * step) * W;
             A2 = H0 + prof(point + c2 * step) * W;
 
-            Y = matrix_exp_puzzer(
-                -step*(a2*A1 + a1*A2),
-                matrix_exp_puzzer(-step*(a1*A1 + a2*A2), Y, 1.0),
-                1.0);
-            
+            omega = -step*(a2*A1 + a1*A2);
+            Y = matrix_exp_puzzer(omega, Y, 1.0);
+
+            omega = -step*(a1*A1 + a2*A2);
+            Y = matrix_exp_puzzer(omega, Y, 1.0);
 
             #ifdef DEBUG_LINTERNALS
                 std::cout << "--------------------" << t << "-------------------" << std::endl;
@@ -183,12 +170,12 @@ public:
         return Y;
     }
 
-    Matrix<complex<double>, 3, 1> Cf4_3(){
-        
+    Matrix<complex<double>, 3, 1> CF4_3()
+    {
         double c1 = 0.5 - sqrt(15.0) / 10.0;
         double c2 = 0.5;
         double c3 = 0.5 + sqrt(15.0) / 10.0;
-        
+
         double a11 = 37.0/240.0 - 10.0*sqrt(15.0)/261.0;
         double a12 = -1.0/30.0;
         double a13 = 37.0/240.0 + 10.0*sqrt(15.0)/261.0;
@@ -198,8 +185,8 @@ public:
         double a31 = 37.0/240.0 + 10.0*sqrt(15.0)/261.0;
         double a32 = -1.0/30.0;
         double a33 = 37.0/240.0 - 10.0*sqrt(15.0)/261.0;
-        
-        Matrix<double, 3, 3> A1, A2, A3, Y1, Y2, Y3;
+
+        Matrix<complex<double>, 3, 3> A1, A2, A3, Y1, Y2, Y3;
         auto Y = v;
         auto point = start;
         while (point < end)
@@ -207,7 +194,7 @@ public:
             A1 = H0 + prof(point + c1 * step) * W;
             A2 = H0 + prof(point + c2 * step) * W;
             A3 = H0 + prof(point + c3 * step) * W;
-            
+
             Y1 = -step*(a11*A1 + a12*A2 + a13*A3);
             Y2 = -step*(a21*A1 + a22*A2 + a23*A3);
             Y3 = -step*(a31*A1 + a32*A2 + a33*A3);
@@ -215,7 +202,7 @@ public:
             Y = matrix_exp_puzzer(Y3, Y, 1.0);
             Y = matrix_exp_puzzer(Y2, Y, 1.0);
             Y = matrix_exp_puzzer(Y1, Y, 1.0);
-            
+
 
             #ifdef DEBUG_LINTERNALS
                 std::cout << "--------------------" << t << "-------------------" << std::endl;
@@ -226,17 +213,17 @@ public:
         return Y;
     }
 
-    void print_more_info(Matrix<complex<double>, 3, 1> v, Methods &m_class)
+    void print_more_info(Matrix<complex<double>, 3, 1>& v)
     {
-        std::cout << "p = " << m_class.p << " q=" << m_class.q << std::endl;
-        std::cout << "lb0 = " << m_class.lbd0 << " lbd1 = " << m_class.lbd1 << " lbd2 = " << m_class.lbd2 << std::endl;
-        std::cout << "a = " << m_class.a << " b = " << m_class.b << " c = " << m_class.c << std::endl;
+        std::cout << "p = " << p << " q=" << q << std::endl;
+        std::cout << "lb0 = " << lbd0 << " lbd1 = " << lbd1 << " lbd2 = " << lbd2 << std::endl;
+        std::cout << "a = " << a << " b = " << b << " c = " << c << std::endl;
 
         std::cout << v << std::endl;
         std::cout << "1-norm " << 1.0 - v.norm() << std::endl;
-        std::cout << "norm0 = " << sqrt(v(0, 0).real() * v(0, 0).real() + v(0, 0).imag() * v(0, 0).imag()) << std::endl;
-        std::cout << "norm1 = " << sqrt(v(1, 0).real() * v(1, 0).real() + v(1, 0).imag() * v(1, 0).imag()) << std::endl;
-        std::cout << "norm2 = " << sqrt(v(2, 0).real() * v(2, 0).real() + v(2, 0).imag() * v(2, 0).imag()) << std::endl;
+        std::cout << "norm0 = " << std::abs(v(0,0)) << std::endl;
+        std::cout << "norm1 = " << std::abs(v(1,0)) << std::endl;
+        std::cout << "norm2 = " << std::abs(v(2,0)) << std::endl;
         std::cout << "arg0 = " << std::arg(v(0, 0)) << std::endl;
         std::cout << "arg1 = " << std::arg(v(1, 0)) << std::endl;
         std::cout << "arg2 = " << std::arg(v(2, 0)) << std::endl;
@@ -244,12 +231,19 @@ public:
 
 private:
     Matrix<complex<double>, 3, 1> v;
-    double v0;
-    double n;
     double start;
     double end;
     double step;
-    vector<double> section;
+    complex<double> p;
+    complex<double> q;
+    complex<double> lbd0;
+    complex<double> lbd1;
+    complex<double> lbd2;
+    complex<double> a;
+    complex<double> b;
+    complex<double> c;
+    complex<double> r0;
+    complex<double> r1;
     function<double(double)> prof; //??
 
     complex<double> calc_lambda(double k, complex<double> p, complex<double> q)
@@ -258,8 +252,8 @@ private:
     }
 
     Matrix<complex<double>, 3, 1> matrix_exp_puzzer(
-        Matrix<complex<double>, 3, 3> matrix,
-        Matrix<complex<double>, 3, 1> vectr,
+        Matrix<complex<double>, 3, 3>& matrix,
+        Matrix<complex<double>, 3, 1>& vectr,
         double t)
     {
         Matrix<double, 3, 3> I;
@@ -269,16 +263,16 @@ private:
         complex<double> z = matrix.trace() / 3.0;
         Matrix<complex<double>, 3, 3> matrix0 = matrix - z * I;
 
-        complex<double> p = (matrix0 * matrix0).trace() * 0.5;
-        complex<double> q = matrix0.determinant();
+        p = (matrix0 * matrix0).trace() * 0.5;
+        q = matrix0.determinant();
 
-        auto lbd0 = calc_lambda(0.0, p, q);
-        auto lbd1 = calc_lambda(1.0, p, q);
-        auto lbd2 = calc_lambda(2.0, p, q);
+        lbd0 = calc_lambda(0.0, p, q);
+        lbd1 = calc_lambda(1.0, p, q);
+        lbd2 = calc_lambda(2.0, p, q);
 
-        complex<double> a = lbd1 - lbd0;
-        complex<double> b = lbd2 - lbd0;
-        complex<double> c = lbd1 - lbd2;
+        a = lbd1 - lbd0;
+        b = lbd2 - lbd0;
+        c = lbd1 - lbd2;
 
         lbd0 *= 2.0 * sqrt(p / 3.0);
         lbd1 *= 2.0 * sqrt(p / 3.0);
@@ -287,19 +281,8 @@ private:
         b *= 2.0 * sqrt(p / 3.0);
         c *= 2.0 * sqrt(p / 3.0);
 
-        //////
-        this->p = p;
-        this->q = q;
-        this->lbd0 = lbd0;
-        this->lbd1 = lbd1;
-        this->lbd2 = lbd2;
-        this->a = a;
-        this->b = b;
-        this->c = c;
-        //////
-
-        complex<double> r0 = -1.0 * (2.0 * sin(a / 2.) * sin(a / 2.) - 1i * sin(a)) / a;
-        complex<double> r1 = -1.0 / c * (-r0 - (2.0 * sin(b / 2.0) * sin(b / 2.0) - 1i * sin(b)) / b);
+        r0 = -1.0 * (2.0 * sin(a / 2.) * sin(a / 2.) - 1i * sin(a)) / a;
+        r1 = -1.0 / c * (-r0 - (2.0 * sin(b / 2.0) * sin(b / 2.0) - 1i * sin(b)) / b);
 
         Matrix<complex<double>, 3, 1> q1 = (1.0 - lbd0 * (r0 - lbd1 * r1)) * vectr;
         Matrix<complex<double>, 3, 1> psi = matrix0 * vectr;
@@ -308,13 +291,6 @@ private:
 
         return exp(1i * t * z) * exp(1i * lbd0 * t) * (q1 + q2 + q3);
     }
-
-    Matrix<complex<double>, 3, 3> calc_commutator(
-        Matrix<complex<double>, 3, 3> A,
-        Matrix<complex<double>, 3, 3> B)
-    {
-        return A * B - B * A;
-    }
 };
 
 int main(int argc, char *argv[])
@@ -358,7 +334,7 @@ int main(int argc, char *argv[])
     double steps = std::stod(argv[3]);
 
     H0 = H0 + W;
-    Methods test = Methods(H0, W, v1, v0, n, prof, start, end, steps);
+    Methods test = Methods(H0, W, v1, prof, start, end, steps);
     std::cout << "H0 = " << H0 << std::endl;
     std::cout << "W = " << W << std::endl;
     std::cout << "v = " << v1 << std::endl;
@@ -373,14 +349,14 @@ int main(int argc, char *argv[])
     if (mthd == "M2") v = test.M2();
     if (mthd == "M4") v = test.M4();
     if (mthd == "M6") v = test.M6();
-    if (mthd == "CF4") v = test.Cf4();
-    if (mthd == "CF4:3") v = test.Cf4_3();
+    if (mthd == "CF4") v = test.CF4();
+    if (mthd == "CF4:3") v = test.CF4_3();
 
     auto end_time = std::chrono::high_resolution_clock::now();
     std::chrono::duration<double> time = (end_time - start_time);
 
     std::cout << "------------------ final ---------------------" << std::endl;
-    test.print_more_info(v, test);
+    test.print_more_info(v);
     std::cout<<"P = "<<std::defaultfloat<<( c12*c12*c13*c13*abs(v(0))*abs(v(0))+
                       s12*s12*c13*c13*abs(v(1))*abs(v(1))+
                       s13*s13*abs(v(2))*abs(v(2)) ) << std::endl;
-- 
2.30.1

